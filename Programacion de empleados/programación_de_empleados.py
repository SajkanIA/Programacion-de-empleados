# -*- coding: utf-8 -*-
"""Programación de empleados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PRNe-coycT2iigH70IPDyy9GGAl6Cksn

#Clase turno
"""

class Departamento():
  """
    Clase creadora de departamentos.
  """
  def __init__(self, nombre, habilidades_requeridas):
    """
      Este metodo constructor agrega el nombre y las habilidades que requiere el
      departamento.
    """
    self.nombre = nombre
    self.habilidades_requeridas = habilidades_requeridas

  def cambia_nombre(self, nuevo_nombre):
    self.nombre = nuevo_nombre

  def cambia_habilidades(self, nueva_habilidad):
    """
      Esta funcion permite cambiar la habilidad requerida.
    """
    self.habilidades_requeridas = nueva_habilidad

  def ver_habilidades(self):
    """
      Esta funcion permite ver la habilidad requerida.
    """
    return self.habilidades_requeridas

  def ver_nombre(self):
    """
      Esta funcion permmite ver el nombre.
    """
    return self.nombre

  def __str__(self):
    return self.nombre

class Turno():
  """
    Esta clase permite crear el turno de trabajo.
  """
  def __init__(self, inicio_del_turno, final_del_turno, departamento,dias , empleado = None):
    """
      Este metodo constructor crea:

      empleado: persona que ocupara el puesto.
      inicio_del_turno: cuando inicia el turno (formato 24 horas).
      final_del_turno: cuando termian el truno (formato 24 horas).
      duracion: duracion del turno.
      departamento: el departamento al que pertence le turno. (Objeto de la clase Departamento)
      dias: dias en los que estaran disponibles el turno.
    """
    self.empleado = empleado
    self.inicio_del_turno = inicio_del_turno
    self.final_del_turno = final_del_turno
    self.departamento = departamento
    self.dias = dias

  def cambio_de_empleado(self, nuevo_empleado):
    self.empleado = nuevo_empleado

  def ver_empleado(self):
    #Visualizador del atributo empleados
    return self.empleado

  def ver_inicio_del_turno(self):
    #Visualizador del atributo inicio_del_turno
    return self.inicio_del_turno

  def ver_final_del_turno(self):
    #Visualizador del atributo final_del_turno
    return self.final_del_turno



  def ver_departamento(self):
    #Visualizador del atributo departamento
    return self.departamento

  def ver_dias(self):
    #Visualizador del atributo dias
    return self.dias

def agregar_dep(nombre, habilidades_requeridas):
  """
    Crea el objeto que referencia el departamento

    inputs:
          -> nombre: nombre del departamento
          -> habilidad_requerida: hablididad requerida para participar en el
             departamento.
  """

  nombre = nombre.lower()
  habilidades_requeridas = habilidades_requeridas.lower()
  return Departamento(nombre, habilidades_requeridas)

def crea_dep():
  """
    Esta funcion crea los departamentos que se utilziaran.
  """
  departamentos = []

  while True:
    #Ciclo para agregar todos los departamentos que el usuario elija.
    user_input = input("\n" + "Digite 'S' para salir 'A' para agregar un nuevo departamento... ")

    if user_input.lower() == 's': #Si el usuario pulsa s se sale del bucle
      break

    elif user_input.lower() == 'a': #Si el usuario pulsa a se procede a crear el departamento.
      nombre = input("Digite el nombre. ")
      habilidad_requerida = input('\n' + "Digite las habilidades requeridas. ")\
                                  .lower()
      departamentos.append(agregar_dep(nombre, habilidad_requerida))

    else:
      print('\n' + 'Las opcionse son "S" o "A"')

  return departamentos

def crea_turno(departamentos):
  turno = [] #variable para el almaacenamiento de los turnos
  for departamento in departamentos: #por cada departamento que tengamos crearemos un turno
    user_input = input("Ingrese el inicio del turno, final del turno, "
    + str(departamento) + " en formato 24 horas"+
                       " separado por espacio").split(" ")

    #Agregamos los dias en los que estaran disponibles este turno.
    dias = input("Ingresa los dias del turno separados por un espacio").lower()\
                 .split(" ")

    #vemos si ya hay alguien asignado a ese turno.
    desicion = input("¿Hay alguien designado para ese turno?. Y/N").lower()

    #si lo hay agregamos el turno con la persona a la lista.
    if desicion.lower() == 'y':
      empleado = input("Ingrese el nombre del empleado").lower()
      turno.append(Turno(user_input[0], user_input[1],
            departamento,dias , empleado))
    #si no lo hay agregamos la informacion sin el nombre de la persona.
    else:
        turno.append(Turno(user_input[0], user_input[1],
            departamento, dias))

  return turno

departamentos = crea_dep()
turnos = crea_turno(departamentos)

"""# Empleados"""

class Empleados():

    def __init__(self, nombre, habilidades,hora_de_inicio, hora_de_salida, disponibilidad):
        self.nombre = nombre
        self.habilidades = habilidades
        self.hora_de_inicio = hora_de_inicio
        self.hora_de_salida = hora_de_salida
        self.disponibilidad = disponibilidad

    def cambia_cualidades(self,nombre=None, habilidades=None, disponibilidad=None):
        if nombre is not None:
            self.nombre = nombre
        if habilidades is not None:
            self.habilidades = habilidades
        if disponibilidad is not None :
            self.disponibilidad = disponibilidad

        print(self.disponibilidad,self.habilidades,self.nombre)

    def ver_nombre(self):
      return self.nombre

    def ver_habilidades(self):
      return self.habilidades

    def ver_hora_de_inicio(self):
      return self.hora_de_inicio

    def ver_hora_de_salida(self):
      return self.hora_de_salida

    def ver_disponiblidad(self):
      return self.disponibilidad

def crear_empleados():
  lista_de_empleados = []
  no_salir = True

  while  no_salir:
      nombre = input("Ingrese el nombre: ").lower()
      habilidades = input("Ingrese el habilidades: ").lower()
      disponibilidad = input("Ingrese disponibilidad dias de la persona: ").lower()\
                            .split(" ")
      inicio, salida = input("Ingrese disponibilidad de horario de la persona separado por espacio y en formato 24horas: ").lower()\
                            .split(" ")

      lista_de_empleados.append(Empleados(nombre, habilidades, inicio, salida, disponibilidad))
      respuesta = (input("Quiere dejar de poner empleados?si/no ").lower())
      if respuesta == "si":
        no_salir = False

  return lista_de_empleados



"""for i in lista_de_empleados:
    print(i.retorna_cualidades())"""

empleados = crear_empleados()

"""#Resticciones"""

def comprueva_si_los_turnos_no_estan_cubiertos(turno):

  """
    comprueva_si_los_turnos_estan_cubiertos

    Inputs:
          -> Un objetos
    Output:
          Boolean.
  """

  return turno.ver_empleado() == None

def solo_puede_cubrir_un_turno_al_día(turnos):

  """
    Verifica si la persona cubre mas de un turno

    Inputs:
          -> Una lista de objetos
    Output:
          Boolean.
  """

  l = []

  for i in turnos:
      if i.ver_empleado() not in l:
        l.append(i.ver_empleado())
      else:
        return False
  return True

def hab_persona_vs_hab_dep(hab_persona, hab_departamento):
  """
    Esta funcion revisa si las habilidades de las personas es igual a las
    habilidades requeridas.

    Inputs:
          -> hab_persona: objeto donde se encuentra las habilidades de la persona.
          -> hab_departamento: objeto donde se encuentra las habilidades requeridas
             por el departamento.
    Output:
          Boolean.
  """
  return hab_persona.ver_habilidades() == hab_departamento.departamento.ver_habilidades()

def respeta_disponibilidad(dips_emp, dip_tur):
  """
    Verifica si la persona ocupa la disponibilidad de horario.

    Inputs:
          -> dips_emp: objeto donde se encuentra la disponibilidad de la persona.
          -> dip_tur: objeto donde se encuentra la disponibilidad requeridas
             por el departamento.
    Output:
          Boolean.
  """
  return dips_emp.ver_disponiblidad() == dip_tur.ver_dias()

def backtrack(turnos, empleados):
  """
    Busca la solucion al problema utilizando recursion. Cada vez que se cumple
    restriccion se abre una nueva rama
  """

  lista_de_turnos = turnos.copy()
  if len(lista_de_turnos) == 0:
    return

  turno = lista_de_turnos.pop(0)

  if all([x.ver_empleado() != None for x in turnos]):
    return "Completado correctamente"

  for empleado in empleados:
    if comprueva_si_los_turnos_no_estan_cubiertos(turno):
      if hab_persona_vs_hab_dep(empleado, turno) and respeta_disponibilidad(empleado, turno):
        turno.cambio_de_empleado(empleado)
        backtrack(lista_de_turnos, empleados)

  backtrack(lista_de_turnos, empleados)

  return "Terminado"

backtrack(turnos, empleados)

turnos = turnos
turnos1 = turnos
dominio ={x:empleados.copy() for x in turnos}

def AC3():

    var_l = [(x,y) for x in turnos for y in empleados.copy()]
    while len(var_l) !=0:
        xi,xj = var_l.pop(0)

        if revisar(xi,xj):

            if len(dominio[xi])==0:
                print(var_l)
                return False
            turnos.remove(xj)
            for xk in turnos:
                var_l.append([xk,xi])

    return True
def revisar(xi,xj):
    borrado = False
    for x in dominio[xi]:
        if not any(respeta_disponibilidad(x,y) and comprueva_si_los_turnos_no_estan_cubiertos(x) and solo_puede_cubrir_un_turno_al_día(x) and hab_persona_vs_hab_dep(x,y) for y in dominio[xj]):
            dominio[xi].remove(x)
            borrado = True

    return borrado
#and comprueva_si_los_turnos_no_estan_cubiertos() and hab_persona_vs_hab_dep() and solo_puede_cubrir_un_turno_al_día()

print(dominio)

for x in dominio.keys():
    y = x

print(y)

for key, value in dominio.items():
    print(f'{key}: {value}')

AC3()

